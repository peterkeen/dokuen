#!/usr/bin/env ruby

$stdout.sync = true

require "rubygems"
require 'foreman'
require 'foreman/procfile'
require 'foreman/process'
require 'daemons'

begin
  require 'dokuen'
rescue LoadError => e
  path = File.expand_path '../../lib', __FILE__
  $:.unshift(path) if File.directory?(path) && !$:.include?(path)
  require 'dokuen'
end

app, proc, index, port = ARGV[0,4]

if app.nil? || proc.nil? || index.nil? || port.nil?
  puts "usage: dokuen-wrapper [app] [proc] [index] [port]"
  exit!
end

Dokuen.read_env("_common")
Dokuen.read_env(app)

procfile = Foreman::Procfile.new(File.join(ENV['DOKUEN_RELEASE_DIR'], 'Procfile'))
entry = procfile[proc]

if entry.nil?
  puts "Procfile at #{ENV['DOKUEN_RELEASE_DIR']}/Procfile does not contain an entry for #{proc}"
  exit!
end

# Daemons.daemonize
#   :app_name => "#{proc}.{index}",
#   :dir_mode => :normal,
#   :dir => ENV['DOKUEN_RELEASE_DIR'] + "/.dokuenprocs",
#   :log_output => false

log_path = File.join(Dokuen.dir("log", app), "#{proc}.#{index}.log")
log_file = File.open(log_path, "a")

loop do
  reader, writer = (IO.method(:pipe).arity == 0 ? IO.pipe : IO.pipe("BINARY"))
  process = Foreman::Process.new(entry, index.to_i, port.to_i)
  process.run(writer, ENV['DOKUEN_RELEASE_DIR'], {})
  thread = Thread.new do
    loop do
      data = reader.gets
      next unless data
      ps, message = data.split(",", 2)
      log_file.puts("[#{Time.now.strftime('%Y-%m-%d %H:%M:%S')}][#{ps}] #{message}")
    end
  end
  Process.wait(process.pid)
  thread.exit
  reader.close
  writer.close
  puts "restarting"
end
